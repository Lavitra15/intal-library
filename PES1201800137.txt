DAA PROJECT REPORT
by Lavitra Kshitij Madan, PES1201800137, Sec 4-A.

INTRODUCTION
This mini-project is about "intal". Intals are basically strings that hold numbers only. These can hold non-negative numbers of variable length. The basic structure of an intal is that it holds 1 or more digits followed by a null-character or string-terminator, denoted by "\0". In this project, intals are stored in big-endian style. "Intals" differ from "int", or integer class in general, as they do not have a limit to the number of digits that can be stored in it whereas the maximum value that int can store is 2 raised to the power 16 which is sometimes not enough if the application requires bigger numbers. Intals can hold numbers that even long long ints cannot hold. So, it gives us more range to work with. Secondly, the common operations that are performed on numbers such as addition, subtraction, multiplication, etc. are not as easy to perform on intals as compared to ints because afterall intal is a derived data-type and so the programmers have to take care for operations that can be performed on them. This project focuses on these operations and how we can make them easy-to-use. The third and the most important difference between intals and ints is that the digits of intals can be individually and randomly accessed whereas for ints, it becomes difficult as we have to make multiple divide and modulus operations on it to fetch a digit out of the number.
Now that we have seen the difference between intals and ints, a few applications of intals are worthy to be mentioned such as- Scientifc calculations, Cryptography, Finance and Economy, Database systems and many more. Science sometimes throws numbers that are extremely huge, such as Avogadro's number, distance from the Earth to the Sun, population of all living species on the Earth, etc. Sometimes these numbers have to be fed into a computer to make calculations and predictions but these cannot be held by the largest member of the integer class and so intals can be used in cases like these. The sector of Finance and Economy finds a huge application of intals as calculations large numbers that countries and businesses deal with, such as lakhs of crores, can only be handled by intals. This is why intals are very important, especially to C Programmimng.

APPROACH
There are a total of 16 parts to the problem. Approaches to all the parts are mentioned below.
1) Addition: The function intal_add takes to intals, adds them up and returns a new intal. Firstly, we take the lengths of the two intals and compare them. Intals are swapped if the length of first intal is lesser than the second intal so that first intal holds the number with more number of digits. This is done to make the process easier. A new intal is declared and memory is allocated. Then, while traversing through the length of the second intal from right to left, we add up individual digits while taking care of the carry-forwards. The appropriate digit is then stored to the result intal from right to left in the appropriate position. Then, while taking care of the carry-forwards, we copy the remaining digits of the first intal to the result, if any. This is done using a second loop that runs for the remaining length of the result intal. Then, the leftmost location of the result intal is taken care of, if any carry is left, it is added there. Finally, if there is a 0 in the  leftmost position of the result and the result isn't meant to be 0 only, i.e., next character isn't a string terminator, then the zero is removed and the result is returned.
2) Comparision: This function takes in two intals and returns 1 if the first intal is greater than the second intal, -1 if the second intal is greater than the first intal and 0 if the intals are equal. Comparision is first done on the basis of number of digits. If the number of digits of the intals is equql then, the two intals are compared digit-by-digit from left to right. The loop continues until string terminator and till the digits are equal. As and when digits lose their equality, the result is returned accordingly. If the loop gets executed completely, 0 is returned as both the intals are equal.
3) Difference: The logic of difference is similar to that of addition. It takes 2 intals and returns the non-negative difference of the two intals. First, the two intals are compared and the greater intal is placed as the first intal. Then a loop runs from right to left throughout the length of the smaller intal. Numbers are subtracted, borrow is taken care of and results are placed into the result intal accordingly. At each step if difference becomes less than 0, a borrow is subtracted from the differece to the immediate left. Then a second loop runs for the remainder of the length of the result intal taking care of borrow. The result is then returned.
4) Multiplication: Two intals are multiply using the regular primary school method. A result intal is initialised with all 0's of length equal to sum of both the intals. Two loops are used. Outer loop runs through the first intal and the second loop runs through the second intal, both from right to left. Each digit from either intals are multiplied and carry is taken care of, then these added to their appropriate positions taking care of overflow. The leading 0's are removed and the result is returned.
5) Modulus: This again uses the regular primary school model of long division but ignores the quoitent fully. If the first intal is smaller than the second intal, the value of the smaller intal is returned. If the values of the two intals is equal, 0 is returned. However, if first intal is greater, long dividion is performed. A loop is run for an amount equal to the difference of lengths of the two intals plus one. In each iteration, digits are picked from left to right from the first intal where thenumber of digits is equal to the number of digits of the second intal initially, it is compared and subtracted if greater until it becomes less than intal2, then the remainder is multiplied by 10 and then next digit from first intal is added and this process repeats. We are then left with the remainder of the two intals and it is returned.
6) Power: This function accepts two parameters and returns an intal equal to first raised to the second. This is done by using divide and conquer strategy. if first intal is 0, 0 is returned. If second number is 0, 1 is returned. Otherwise, if n is odd, the function is called recursively for the same first parameter and second parameter becomes (n-1)/2, then the result is multiplied with itself and then with the first intal again. If n was even, n/2 is passed as second paramenter and the result is multiplied by itself.
7) GCD: This uses the normal Euclid method where first intal is greater and first intal mod second intal is not equal to 0. The loop is run and first intal takes second intal and second intal takes the mod of the two. The answer is then returned.
8) Fibonacci: This takes a parameter as a number till and expects the fibonacci at that position. Two intals are initailised with 0 and 1 and a loop is run from 2 to n where the two number are added and the first intal holds the second intal and second intal holds the sum. After the loop is executed fully, the second intal is returned.
9) Factorial: This function uses the property of n! = n * (n-1)!. A result intal is initialised with value 1 and then numbers are multiplied to it starting from n to 1. This is done using a loop and at each iteration, multiplication function is used. The reuslt is then returned.
10) Binary Coefficient: Firstly, it is made sure that k is lesser than half of n so that unnecessary calculations can be avoided. If it is greater than half of n, it is made to n-k, because of the property nCk = nC(n-k). Then using DP of sliding window, we declare an array of pointers of size k+1 and using Pascal's triangle property of nCk = n-1Ck-1 + n-1Ck, we calculate the values of the array of intals but we use n and not n-1 so the values get replaced because we do not need all of the table. Then the required value is returned.
11) Max: This function runs through the array and first allocates the first element as the maximum and in the loop if it comes across any number that is strictly greater than the maximum using Comparision function, it takes that value as the maximum and after the loop is finished, it returns the offset of the maximum.
12) Min: This function runs through the array and first allocates the first element as the minimum and in the loop if it comes across any number that is strictly lesser than the minimum, it takes that value as the minimum and after the loop is finished, it returns the offset of the minimum. It uses the comparision function
13) Search: This function runs through the array and searched for the element. It is basically a linear search. As it encounters a number in the array equal to the key, using comparision function, it returns the offset that element. If the loop gets exhausted it reurns -1.
14) Binary Search: This function uses binary search technique to search for the first occurance of an intal in an array. It is iterative and finds the mid of the array it is searching in and then if key is less than that intal, it searches in first half, if it is greater, it searches in the next half, if it is equal, it searches for mid of the left half of the array, if that it is also equal it searches for the next mid and it goes on until a mid is found where the key is not equal to that mid. That mid and the previous mid are considered and  it is searched in between these two from both ends and finally the first occurance's offset is returned.
15) Sort: This function uses the exact same version of the famous merge sort just that int is replcaed by intal. The array is first divided recursively and all of them are sorted while merging. It uses two other functions called merge and mergesort. Mergesort is the function that keeps dividing and calling itself and merge sorts them while joining.
16) Coin-Row Problem: This function uses sliding window concept of Dynamic Programming and only three pointers are used that keep taking different intals. First, the firsts pointer is intialised with intal holdong value 0 and second intal holds the first from the array. A loop runs and the third intal holds the max of sum of first intal added with next intal from array and the second intal. Then first intal holds second intal, second holds the third and the intal that was previously held by intal1 is freed. The third intal after loop is then returned.

MORE FUNCTIONALITIES:
A) Functions from other feilds such as calculus, trigonometry can be added.
B) Restrictions such as non-negativity can be removed. It can also be extended to decimals.